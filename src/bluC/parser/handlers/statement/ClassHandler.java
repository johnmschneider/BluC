package bluC.parser.handlers.statement;

import java.util.ArrayList;
import bluC.Logger;
import bluC.transpiler.Scope;
import bluC.transpiler.Statement;
import bluC.transpiler.Statement.ClassDef;
import bluC.transpiler.Token;
import bluC.transpiler.TokenFileInfo;
import bluC.transpiler.TokenInfo;
import bluC.parser.Parser;

/**
 * @author John Schneider
 */
public class ClassHandler
{
    public static final String CLASS_NAMESPACE_PREFIX   = "class";
    public static final long CLASS_UNSPECIFIED          = Long.MIN_VALUE;
            
    private Parser          parser; 
    private VariableHandler varHandler;
    private BlockHandler    blockHandler;
    private FunctionHandler funcHandler;
    
    /**
     * Reserve Long.MIN_VALUE for Statement.VarDeclaration to use as a sentinel
     *  value meaning "no class specified"
     */
    private static long unresolvedClassNames = Long.MIN_VALUE + 1;
    private static ArrayList<ClassDef> classDefinitions = new ArrayList<>();
    
    public ClassHandler(Parser parser, VariableHandler varHandler, 
        BlockHandler blockHandler, FunctionHandler funcHandler)
    {
        this.parser = parser;
        this.varHandler = varHandler;
        this.blockHandler = blockHandler;
        this.funcHandler = funcHandler;
    }

    public Statement handleClass(Token classKeyword)
    {
        ClassDef classDef;
        Token next;
        Token className;
        Token superClass;
        
        parser.nextToken();
        next = parser.peek();

        if (next.isValidName()) 
        {
            className = next;
        }
        else
        {
            className = getAutoGeneratedName(classKeyword);
        }
        
        classDef = new ClassDef(className, classKeyword.getLineIndex());
        
        parser.nextToken();
        superClass = getSuperClass();
        
        next = parser.peek();
        
        parser.pushScope(new Scope(parser.getCurrentScope(), classDef));
        
        //push incomplete class definition here so that parser can recognize
        //  reference to this class that might be inside itself
        classDefinitions.add(classDef);
        
        if (next.getTextContent().equals("{"))
        {
            //parser.nextToken();
            blockHandler.addStatementsToBlock(next, classDef);
        }
        else 
        {
            Logger.err(next, "Expected \"{\" to open class \"" + 
                className.getTextContent() + "\" on line " + 
                (className.getLineIndex() + 1));
            blockHandler.addStatementsToBlock(next, classDef);
        }
        
        parser.nextToken(); // move past "}" token
        parser.popScope(parser.getCurToken());
        
        return classDef;
    }
    
    private Token getAutoGeneratedName(Token classKeyword) 
    {
        Token returnee = new Token(
            new TokenInfo("unresolvedClassName" + 
                Long.toUnsignedString(unresolvedClassNames), true),
                
            new TokenFileInfo(classKeyword.getFilepath(), 
                classKeyword.getLineIndex()));
        unresolvedClassNames++;
        
        return returnee;
    }
    
    // TODO : implement this method fully
    /**
     * AS OF RIGHT NOW THIS IS NOT IMPLEMENTED. However, the parser still ends
     *  on { as stated.
     * 
     * Parses the superclass after the "extends" keyword (if it exists). If 
     *  there is no "extends" keyword, then the token returns the token "Object"
     *  as the superclass.
     * 
     * Leaves the parser on the last token of the extension. If there is no
     *  superclass (i.e. extending Object), this method should leave the parser
     *  on the class name token.
     * 
     *  For example: "class A extends B {}" should leave the parser on token B.
     *  "class A extends B implements C {}" should leave the parser on token C.
     */
    private Token getSuperClass()
    {
        Token next = parser.peek();
        
        return new Token(
            new TokenInfo("Object", true),
            
            new TokenFileInfo(next.getFilepath(), next.getLineIndex()));
    }
    
    public static ArrayList<ClassDef> getClassDefinitions()
    {
        return classDefinitions;
    }
    
    public static long getClassID(Token className)
    {
        for (ClassDef class_ : classDefinitions)
        {
            //TODO : add package check too
            if (class_.getClassName().getTextContent().equals(
                            className.getTextContent()))
            {
                return class_.getClassID();
            }
        }
        
        return CLASS_UNSPECIFIED;
    }
    
    public static boolean isClassDefined(Token className)
    {
        return getClassID(className) != CLASS_UNSPECIFIED;
    }
    
    public static ClassDef getClassDefinition(long classID)
    {
        for (ClassDef class_ : classDefinitions)
        {
            if (class_.getClassID() == classID)
            {
                return class_;
            }
        }
        
        return null;
    }
}
