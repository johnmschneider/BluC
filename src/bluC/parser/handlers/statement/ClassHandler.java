/*
 * Copyright 2021 John Schneider.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bluC.parser.handlers.statement;

import java.util.ArrayList;
import bluC.Logger;
import bluC.transpiler.Scope;
import bluC.transpiler.statements.Statement;
import bluC.transpiler.statements.blocks.ClassDef;
import bluC.transpiler.Token;
import bluC.transpiler.TokenFileInfo;
import bluC.transpiler.TokenInfo;
import bluC.parser.Parser;

/**
 * @author John Schneider
 */
public class ClassHandler
{
    public static final String CLASS_NAMESPACE_PREFIX   = "class";
            
    private final Parser          parser;
    private final VariableHandler varHandler;
    private final BlockHandler    blockHandler;
    private final FunctionHandler funcHandler;
    
    /**
     * Reserve Long.MIN_VALUE for Statement.VarDeclaration to use as a sentinel
     *  value meaning "no class specified"
     */
    private static long unresolvedClassNames = Long.MIN_VALUE + 1;
    private static final ArrayList<ClassDef> CLASS_DEFINITIONS = 
        new ArrayList<>();
    
    public ClassHandler(Parser parser, VariableHandler varHandler, 
        BlockHandler blockHandler, FunctionHandler funcHandler)
    {
        this.parser = parser;
        this.varHandler = varHandler;
        this.blockHandler = blockHandler;
        this.funcHandler = funcHandler;
    }

    public Statement handleClass(Token classKeyword)
    {
        ClassDef classDef;
        Token next;
        Token className;
        Token superClass;
        
        parser.nextToken();
        next = parser.peek();

        if (next.isValidName()) 
        {
            className = next;
        }
        else
        {
            String message = "Class name of \"" + next.getTextContent() + 
                "\" is ";
            
            if (next.isReservedLexeme())
            {
                message += "a lexeme or keyword reserved by the compiler";
            }
            else if (next.isFutureReservation())
            {
                message += "using the name of a potential future keyword or " +
                    "lexeme (two underscores \"__\" followed by an " + 
                    "alphanumeric character)";
            }
            
            Logger.err(next, message);
            className = getAutoGeneratedName(classKeyword);
        }
        
        classDef = new ClassDef(className, classKeyword.getLineIndex());
        
        parser.nextToken();
        superClass = getSuperClass();
        
        next = parser.peek();
        
        parser.pushScope(new Scope(parser.getCurrentScope(), classDef));
        
        //push incomplete class definition here so that parser can recognize
        //  reference to this class that might be inside itself
        CLASS_DEFINITIONS.add(classDef);
        
        // move to either "{" or the token we are going to synchronize as "{"
        parser.nextToken();
        
        if (next.getTextContent().equals("{"))
        {
            blockHandler.addStatementsToBlock(next, classDef);
        }
        else 
        {
            Logger.err(next, "Expected \"{\" to open class \"" + 
                className.getTextContent() + "\" on line " + 
                (className.getLineIndex() + 1));
            blockHandler.addStatementsToBlock(next, classDef);
        }
        
        parser.popScope(parser.peek());
        
        return classDef;
    }
    
    private Token getAutoGeneratedName(Token classKeyword) 
    {
        Token returnee = new Token(
            new TokenInfo("unresolvedClassName" + 
                Long.toUnsignedString(unresolvedClassNames), true),
                
            new TokenFileInfo(classKeyword.getFilepath(), 
                classKeyword.getLineIndex()));
        unresolvedClassNames++;
        
        return returnee;
    }
    
    // TODO : implement this method fully
    /**
     * AS OF RIGHT NOW THIS IS NOT IMPLEMENTED. However, the parser still ends
     *  on { as stated.
     * 
     * Parses the superclass after the "extends" keyword (if it exists). If 
     *  there is no "extends" keyword, then the token returns the token "Object"
     *  as the superclass.
     * 
     * Leaves the parser on the last token of the extension. If there is no
     *  superclass (i.e. extending Object), this method should leave the parser
     *  on the class name token.
     * 
     *  For example: "class A extends B {}" should leave the parser on token B.
     *  "class A extends B implements C {}" should leave the parser on token C.
     */
    private Token getSuperClass()
    {
        Token next = parser.peek();
        
        return new Token(
            new TokenInfo("Object", true),
            
            new TokenFileInfo(next.getFilepath(), next.getLineIndex()));
    }
    
    public static ArrayList<ClassDef> getCLASS_DEFINITIONS()
    {
        return CLASS_DEFINITIONS;
    }
    
    public static String getClassID(Token className)
    {
        for (ClassDef class_ : CLASS_DEFINITIONS)
        {
            //TODO : add package check too
            if (class_.getClassName().getTextContent().equals(
                            className.getTextContent()))
            {
                return class_.getClassID();
            }
        }
        
        return ClassDef.NOT_DEFINED;
    }
    
    public static boolean isClassDefined(Token className)
    {
        return !getClassID(className).equals(ClassDef.NOT_DEFINED);
    }
    
    public static ClassDef getClassDefinition(String classID)
    {
        for (ClassDef class_ : CLASS_DEFINITIONS)
        {
            if (class_.getClassID().equals(classID))
            {
                return class_;
            }
        }
        
        return null;
    }
}
